aic <- infocriteria(model$fit)[1]
bic <- infocriteria(model$fit)[2]
shib <- infocriteria(model$fit)[3]
han <- infocriteria(model$fit)[4]
# Store the results
results <- rbind(results, data.frame(garch.r = garch.r, garch.s = garch.s,
ar = ar, ma = ma,
AIC = aic, BIC = bic,
SHIB = shib, HAN = han))
}, silent = TRUE)
}
}
# Find the model with the lowest AIC and BIC
best_aic_model <- results[which.min(results$AIC), ]
best_bic_model <- results[which.min(results$BIC), ]
best_shib_model <- results[which.min(results$SHIB), ]
best_han_model <- results[which.min(results$HAN), ]
# Print the best models
print("Best ARMA model by AIC:")
print(best_aic_model)
print("Best ARMA model by BIC:")
print(best_bic_model)
print("Best ARMA model by SHIB:")
print(best_shib_model)
print("Best ARMA model by HAN:")
print(best_han_model)
########## FINAL MODEL
garch <- do_garch(garch.model = "sGARCH",
garch.r = 1,
garch.s = 1,
data = log_returns$daily.returns,
dist.model = "norm",
ar = 1,
ma = 2)
par(mfrow = c(1, 1))
plot.ts(garch$residuals, main = "Residuals of GARCH model", ylab = "Residuals")
plot.ts(garch$squared_residuals, main = "Squared Residuals of GARCH model", ylab = "Squared Residuals")
# ACF analysis for residuals
# This will allow you to check the adequacy of the GARCH(1,1) model by examining whether the residuals
# and their squared values exhibit any significant autocorrelation. If the ACF and PACF plots show no
# significant autocorrelation, and have a N(0,1) white noise behaviour, the model is considered a good fit for the data.
par(mfrow = c(2, 2))
acf(garch$residuals, main = "ACF of Standardized Residuals")
pacf(garch$residuals, main = "PACF of Standardized Residuals")
acf(garch$squared_residuals, main = "ACF of Squared Standardized Residuals")
pacf(garch$squared_residuals, main = "PACF of Squared Standardized Residuals")
par(mfrow = c(1, 1))
########## FORECASTING #################################
results
print("Best ARMA model by AIC:")
print(best_aic_model)
print("Best ARMA model by BIC:")
print(best_bic_model)
print("Best ARMA model by SHIB:")
print(best_shib_model)
print("Best ARMA model by HAN:")
print(best_han_model)
aic <- infocriteria(model$fit)[1]
bic <- infocriteria(model$fit)[2]
shib <- infocriteria(model$fit)[3]
han <- infocriteria(model$fit)[4]
aic
model$fit
# plot
ggplot(log_returns, aes(x = Date, y = daily.returns)) +
geom_line(color = "blue") +  # Plot the time series data
geom_smooth(method = "lm", color = "red", se = FALSE) +  # Add the linear trend line
labs(title = "Time Series Data with Linear Trend",
x = "Date",
y = "Value") +
theme_minimal()
ggplot(log_returns, aes(x = Date, y = daily.returns)) +
geom_line(color = "blue") +  # Plot the time series data
geom_smooth(method = "lm", color = "red", se = FALSE) +  # Add the linear trend line
labs(title = "Trend Plot for Daily Returns",
x = "Date",
y = "Value") +
theme_minimal()
ts.plot(log_returns)
model <- lm(data = log_returns, daily.returns ~ Date)
model
summary(model)
garch <- do_garch(garch.model = "sGARCH",
garch.r = 1,
garch.s = 1,
data = log_returns$daily.returns,
dist.model = "norm",
ar = 1,
ma = 2)
shapiro.test(garch$residuals)
garch$residuals
shapiro.test(garch$residuals[,1])
garch$residuals[,1]
garch$squared_residuals
garch$residuals
as.vector(garch$residuals)
shapiro.test(as.vector(garch$residuals))
?shapiro.test
shapiro.test(rnorm(100, mean = 5, sd = 3))
?residuals.Arima
?residuals
########## FORECASTING #################################
predict(garch$fit,n.ahead=24,plot=TRUE)
########## FORECASTING #################################
forecast_horizon <- 10
garch_forecast <- ugarchforecast(garchl$fit, n.ahead = forecast_horizon)
garch_forecast <- ugarchforecast(garch$fit, n.ahead = forecast_horizon)
# Extract the forecasted values
forecasted_values <- fitted(garch_forecast)
forecasted_sigma <- sigma(garch_forecast)
# Print the forecasted values and sigma
print(forecasted_values)
print(forecasted_sigma)
# Plot the forecasted values
forecast_dates <- seq(max(log_returns$Date) + 1, by = "day", length.out = forecast_horizon)
forecast_df <- data.frame(Date = forecast_dates, Forecasted_Returns = forecasted_values)
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
labs(title = "GARCH Model Forecast",
x = "Date",
y = "Daily Returns") +
theme_minimal()
forecast_df
forecast_df <- data.frame(Date = forecast_dates, Forecasted_Returns = forecasted_values)
forecast_df
forecasted_values
colnames(forecast_df) <= c("Date", "Forecasted_Returns")
colnames(forecast_df) <- c("Date", "Forecasted_Returns")
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
labs(title = "GARCH Model Forecast",
x = "Date",
y = "Daily Returns") +
theme_minimal()
########## FORECASTING #################################
# Forecast the next 10 days
forecast_horizon <- 100
garch_forecast <- ugarchforecast(garch$fit, n.ahead = forecast_horizon)
# Extract the forecasted values and confidence intervals
forecasted_values <- fitted(garch_forecast)
forecasted_sigma <- sigma(garch_forecast)
forecasted_upper <- forecasted_values + 1.96 * forecasted_sigma
forecasted_lower <- forecasted_values - 1.96 * forecasted_sigma
# Print the forecasted values and sigma
print(forecasted_values)
print(forecasted_sigma)
print(forecasted_upper)
print(forecasted_lower)
# Create a data frame for plotting
forecast_dates <- seq(max(log_returns$Date) + 1, by = "day", length.out = forecast_horizon)
forecast_df <- data.frame(Date = forecast_dates,
Forecasted_Returns = forecasted_values,
Upper_CI = forecasted_upper,
Lower_CI = forecasted_lower)
forecast_df
colnames(forecast_df) <- c("Date", "Forecasted_Returns", "Upper_CI", "Lower_CI")
# Plot the forecasted values with confidence intervals
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Combine the last 10 days of actual data with the forecast
plot_data <- rbind(last_10_days, forecast_df)
last_10_days <- tail(log_returns, 10)
# Combine the last 10 days of actual data with the forecast
plot_data <- rbind(last_10_days, forecast_df)
# Plot the last 10 days and the forecast
ggplot() +
geom_line(data = last_10_days, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Plot the forecasted values with confidence intervals
last_10_days <- tail(log_returns, 10)
# Combine the last 10 days of actual data with the forecast
plot_data <- rbind(last_10_days, forecast_df)
# Plot the last 10 days and the forecast
ggplot() +
geom_line(data = last_10_days, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals - 10 days",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Calculate rolling volatility
rolling_vol <- rollapply(log_returns$daily.returns, width = 30, FUN = sd, na.rm = TRUE, align = 'right')
predicted_volatility <- c(rolling_vol, forecasted_sigma)
ggplot() +
geom_line(data = last_10_days, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
geom_line(aes(x = c(last_10_days$Date, forecast_dates), y = predicted_volatility), color = "green", linetype = "dashed") +
labs(title = "GARCH Model Forecast with Confidence Intervals and Predicted Volatility",
x = "Date",
y = "Daily Returns / Volatility") +
theme_minimal()
# Calculate rolling volatility
rolling_vol <- rollapply(log_returns$daily.returns, width = 30, FUN = sd, na.rm = TRUE, align = 'right')
# Extend the rolling volatility with forecasted sigma
extended_rolling_vol <- c(rolling_vol, rep(NA, length(last_10_days$Date) + forecast_horizon - length(rolling_vol)))
rolling_vol <- rollapply(log_returns$daily.returns, width = 30,
FUN = sd, na.rm = TRUE, align='right')
vol <- data.frame(index(rolling_vol), rolling_vol)
colnames(vol) <- c("date", "volatility")
p3 <- ggplot(vol, aes(x=date, y=volatility))
p3 +
geom_line( color="steelblue") +
labs(title="Daily return volatility over Time",
x="Day",
y="Volatility")
# Initialize variables
n <- length(log_returns$daily.returns)
rolling_forecast_sigma <- numeric(n - 30)  # Adjust size according to rolling window
# Rolling forecast
for (i in 31:n) {
train_data <- log_returns$daily.returns[1:i]
# Fit the GARCH model
spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(1, 2)),
distribution.model = "norm")
fit <- ugarchfit(spec, train_data, solver = "hybrid")
# Forecast one step ahead
forecast <- ugarchforecast(fit, n.ahead = 1)
# Store the forecasted sigma
rolling_forecast_sigma[i - 30] <- sigma(forecast)
}
warnings()
# Initialize variables
n <- length(log_returns$daily.returns)
rolling_forecast_sigma <- numeric(n - 30)  # Adjust size according to rolling window
# Rolling forecast
for (i in 31:n) {
train_data <- log_returns$daily.returns[1:i]
# Fit the GARCH model
spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(1, 2)),
distribution.model = "norm")
fit <- ugarchfit(spec, train_data, solver = "hybrid")
# Forecast one step ahead
forecast <- ugarchforecast(fit, n.ahead = 1)
# Store the forecasted sigma
rolling_forecast_sigma[i - 30] <- sigma(forecast)
}
# Create a data frame for plotting
rolling_forecast_dates <- log_returns$Date[31:n]
rolling_forecast_df <- data.frame(Date = rolling_forecast_dates, Predicted_Volatility = rolling_forecast_sigma)
# Plot predicted volatility
ggplot(rolling_forecast_df, aes(x = Date, y = Predicted_Volatility)) +
geom_line(color = "red") +
labs(title = "One-Step Ahead Rolling Forecast of Volatility",
x = "Date",
y = "Predicted Volatility") +
theme_minimal()
n
# Initialize variables
n <- length(log_returns$daily.returns)
rolling_forecast_sigma <- numeric(n - 1000)  # Adjust size according to rolling window
# Rolling forecast
for (i in 1001:n) {
train_data <- log_returns$daily.returns[1:i]
# Fit the GARCH model
spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(1, 2)),
distribution.model = "norm")
fit <- ugarchfit(spec, train_data, solver = "hybrid")
# Forecast one step ahead
forecast <- ugarchforecast(fit, n.ahead = 1)
# Store the forecasted sigma
rolling_forecast_sigma[i - 30] <- sigma(forecast)
}
# Create a data frame for plotting
rolling_forecast_dates <- log_returns$Date[31:n]
rolling_forecast_df <- data.frame(Date = rolling_forecast_dates, Predicted_Volatility = rolling_forecast_sigma)
# Plot predicted volatility
ggplot(rolling_forecast_df, aes(x = Date, y = Predicted_Volatility)) +
geom_line(color = "red") +
labs(title = "One-Step Ahead Rolling Forecast of Volatility",
x = "Date",
y = "Predicted Volatility") +
theme_minimal()
# Initialize variables
n <- length(log_returns$daily.returns)
rolling_forecast_sigma <- numeric(n - 1000)  # Adjust size according to rolling window
# Rolling forecast
for (i in 1001:n) {
train_data <- log_returns$daily.returns[1:i]
# Fit the GARCH model
spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(1, 2)),
distribution.model = "norm")
fit <- ugarchfit(spec, train_data, solver = "hybrid")
# Forecast one step ahead
forecast <- ugarchforecast(fit, n.ahead = 1)
# Store the forecasted sigma
rolling_forecast_sigma[i - 1000] <- sigma(forecast)
}
# Create a data frame for plotting
rolling_forecast_dates <- log_returns$Date[1001:n]
rolling_forecast_df <- data.frame(Date = rolling_forecast_dates, Predicted_Volatility = rolling_forecast_sigma)
# Extract actual values for comparison
actual_volatility <- log_returns$daily.returns[1001:n]
# Plot predicted volatility with actual values
ggplot() +
geom_line(data = rolling_forecast_df, aes(x = Date, y = Predicted_Volatility), color = "red") +
geom_line(aes(x = rolling_forecast_dates, y = actual_volatility), color = "blue") +
labs(title = "One-Step Ahead Rolling Forecast of Volatility with Actual Values",
x = "Date",
y = "Volatility") +
theme_minimal()
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Plot the last 10 days and the forecast
ggplot() +
geom_line(data = last_10_days, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Plot the last 10 days and the forecast
ggplot() +
geom_line(data = last_10_days, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals - Last 10 days",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Load data
data_microsoft <- read.csv("~/Desktop/Time-Series-project/data/Microsoft_Stock.csv")
data_microsoft$Date <- as.Date(data_microsoft$Date, format="%m/%d/%Y %H:%M:%S")
# Transform data
log_returns <- tq_transmute(data_microsoft, select = Close, mutate_fun = periodReturn, period = "daily", type = "log")
# Plot ACF and PACF of log returns and squared log returns
par(mfrow = c(2, 1))
acf(log_returns$daily.returns, main = "ACF of Daily Returns")
pacf(log_returns$daily.returns, main = "PACF of Daily Returns")
# Train-test split (80-20)
set.seed(123)
n <- length(log_returns$daily.returns)
train_size <- floor(0.8 * n)
train_data <- log_returns$daily.returns[1:train_size]
test_data <- log_returns$daily.returns[(train_size + 1):n]
test_dates <- log_returns$Date[(train_size + 1):n]
# Fit GARCH model on training data
spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(1, 2)),
distribution.model = "norm")
fit <- ugarchfit(spec, train_data, solver = "hybrid")
# Forecast based on test data
forecast_horizon <- length(test_data)
garch_forecast <- ugarchforecast(fit, n.ahead = forecast_horizon)
# Extract forecasted values and confidence intervals
forecasted_values <- fitted(garch_forecast)
forecasted_sigma <- sigma(garch_forecast)
forecasted_upper <- forecasted_values + 1.96 * forecasted_sigma
forecasted_lower <- forecasted_values - 1.96 * forecasted_sigma
# Create data frame for plotting
forecast_df <- data.frame(Date = test_dates,
Forecasted_Returns = forecasted_values,
Upper_CI = forecasted_upper,
Lower_CI = forecasted_lower)
# Plot forecasted returns with confidence intervals
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Create data frame for plotting
forecast_df <- data.frame(Date = test_dates,
Forecasted_Returns = forecasted_values,
Upper_CI = forecasted_upper,
Lower_CI = forecasted_lower)
colnames(forecast_df) <- c("Date", "Forecasted_Returns", "Upper_CI", "Lower_CI")
# Plot forecasted returns with confidence intervals
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Plot last 10 days and forecast
last_10_days <- tail(log_returns, 10)
plot_data <- rbind(last_10_days, forecast_df)
ggplot() +
geom_line(data = last_10_days, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals - Last 10 Days",
x = "Date",
y = "Daily Returns") +
theme_minimal()
last_10_days
forecast_df
# Plot forecasted returns with confidence intervals
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
# Initialize variables
rolling_forecast_sigma <- numeric(n - 1000)  # Adjust size according to rolling window
# Rolling forecast
for (i in 1001:n) {
train_data <- log_returns$daily.returns[1:i]
# Fit the GARCH model
spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(1, 2)),
distribution.model = "norm")
fit <- ugarchfit(spec, train_data, solver = "hybrid")
# Forecast one step ahead
forecast <- ugarchforecast(fit, n.ahead = 1)
# Store the forecasted sigma
rolling_forecast_sigma[i - 1000] <- sigma(forecast)
}
# Create data frame for plotting
rolling_forecast_dates <- log_returns$Date[1001:n]
rolling_forecast_df <- data.frame(Date = rolling_forecast_dates, Predicted_Volatility = rolling_forecast_sigma)
# Extract actual values for comparison
actual_volatility <- log_returns$daily.returns[1001:n]
# Plot predicted volatility with actual values
ggplot() +
geom_line(data = rolling_forecast_df, aes(x = Date, y = Predicted_Volatility), color = "red") +
geom_line(aes(x = rolling_forecast_dates, y = actual_volatility), color = "blue") +
labs(title = "One-Step Ahead Rolling Forecast of Volatility with Actual Values",
x = "Date",
y = "Volatility") +
theme_minimal()
# Initialize variables
test_start <- train_size + 1
rolling_forecast_sigma <- numeric(length(test_data))  # Adjust size according to rolling window
# Rolling forecast on test data
for (i in test_start:n) {
train_data <- log_returns$daily.returns[1:i]
# Fit the GARCH model
spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(1, 2)),
distribution.model = "norm")
fit <- ugarchfit(spec, train_data, solver = "hybrid")
# Forecast one step ahead
forecast <- ugarchforecast(fit, n.ahead = 1)
# Store the forecasted sigma
rolling_forecast_sigma[i - test_start + 1] <- sigma(forecast)
}
# Create data frame for plotting
rolling_forecast_dates <- log_returns$Date[test_start:n]
rolling_forecast_df <- data.frame(Date = rolling_forecast_dates, Predicted_Volatility = rolling_forecast_sigma)
# Extract actual values for comparison
actual_volatility <- log_returns$daily.returns[test_start:n]
# Plot predicted volatility with actual values
ggplot() +
geom_line(data = rolling_forecast_df, aes(x = Date, y = Predicted_Volatility), color = "red") +
geom_line(aes(x = rolling_forecast_dates, y = actual_volatility), color = "blue") +
labs(title = "One-Step Ahead Rolling Forecast of Volatility with Actual Values",
x = "Date",
y = "Volatility") +
theme_minimal()
# Plot forecasted returns with confidence intervals
ggplot() +
geom_line(data = log_returns, aes(x = Date, y = daily.returns), color = "blue") +
geom_line(data = forecast_df, aes(x = Date, y = Forecasted_Returns), color = "red") +
geom_ribbon(data = forecast_df, aes(x = Date, ymin = Lower_CI, ymax = Upper_CI), alpha = 0.2, fill = "red") +
labs(title = "GARCH Model Forecast with Confidence Intervals",
x = "Date",
y = "Daily Returns") +
theme_minimal()
library(stats)
library(astsa)
library(tseries)
library(dplyr)
library(ggplot2)
library(rugarch)
library(rmgarch)
library(quantmod)
library(tidyquant)
library(dplyr)
library(forecast)
library(trend)
?ugarchspec
